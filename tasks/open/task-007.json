{
  "id": "task-007",
  "created": "2025-11-11T08:47:14Z",
  "updated": "2025-11-12T02:00:00Z",
  "title": "Create Logger module with SPIFFS persistence and boot sequencing",
  "status": "open",
  "priority": "high",
  "description": "Implement Logger class for consistent logging with system monitoring data and SPIFFS persistence. Logger writes to /data/active.log in JSON-line format with system stats (heap, memory, uptime, SPIFFS usage) and boot sequence info attached to every entry. NO timestamp written to file—timestamps calculated on send by NetworkLogger based on NTP sync status. System stat gathering triggers rotation check at 80% capacity. Must be available before other modules initialize. Part of bidirectional TCP logging architecture with network task handling sync.",
  "assigned_to": null,
  "acceptance_criteria": [
    "Logger class created in src/logger.h/.cpp",
    "logDebug(), logInfo(), logWarning(), logError() methods with format strings",
    "Boot sequence counter maintained in /data/boot_counter.json (incremented on each boot)",
    "System stats attached to every entry: heap_free, heap_used, uptime_ms, free_psram, task_count, spiffs_free, spiffs_used",
    "Boot sequence number included in every entry: boot_seq",
    "Entry sequence number maintained per-boot: seq (increments per log call)",
    "Serial output to stdout for boot debugging",
    "SPIFFS initialization with /data/ directory on begin()",
    "Append JSON-line format to /data/active.log: {\"boot_seq\":3,\"uptime_ms\":45000,\"seq\":42,\"level\":\"...\",\"msg\":\"...\",\"system\":{...}}\n",
    "NO ts field written to file (timestamp calculated on send by NetworkLogger)",
    "Mutex protect active.log access to prevent corruption during concurrent reads/writes with NetworkLogger",
    "Entry size limit: cap message at 512 bytes, truncate if exceeded",
    "If message truncated: log error entry: {\"level\":\"error\",\"msg\":\"Log entry truncated (X chars), original: ...first 256 chars...\"}",
    "getSystemStats() method gathers all metrics in one call",
    "During stat gathering: check active.log size, if > 80% of SPIFFS → start pruning oldest entries",
    "First-boot initialization: check if /data/ exists, create if not; verify boot_counter.json exists, initialize if needed",
    "Circular buffer behavior: cap active.log at 80% of SPIFFS, drop oldest entries when threshold exceeded",
    "Public interface: begin(), logDebug(), logInfo(), logWarning(), logError(), getLogPath(), getSystemStats(), getBootSeq(), getEntrySeq()",
    "Handles SPIFFS full gracefully without crashing logger",
    "Tested: all log levels output to serial and SPIFFS with boot_seq and system stats, rotation at 80% works, truncation handled, first-boot init works, SPIFFS errors handled"
  ],
  "investigation": [
    {
      "timestamp": "2025-11-12T01:30:00Z",
      "action": "Discussed timestamp and NTP sync architecture with user",
      "finding": "Final design: NO ts in file, only uptime_ms + boot_seq + seq for perfect ordering. Timestamps calculated on send by NetworkLogger based on NTP sync history. Handles multiple power cycles without network connectivity. Unresolvable timestamps sent as null to server. Boot sequence counter prevents collisions across reboots."
    }
  ],
  "solution": {
    "approach": "Logger writes directly to SPIFFS append-only file. Read boot_counter.json on startup, include boot_seq in every entry. Every log call: get current seq, gather system stats (heap, memory, uptime, SPIFFS), check capacity—if > 80%, prune oldest entries. Append JSON-line with boot_seq, uptime_ms, seq, level, msg, system (no ts). Increment seq counter. Separate network task handles reading, calculating ts on send based on NTP history, and deleting after TCP ack.",
    "files_to_modify": [
      "src/logger.h",
      "src/logger.cpp",
      "data/boot_counter.json (created on first run)"
    ],
    "changes": "Create Logger singleton with SPIFFS persistence. On begin(): read/initialize boot_counter.json, read/initialize entry seq counter. getSystemStats() retrieves heap, PSRAM, task count, SPIFFS usage. Write method appends JSON-line to active.log with boot_seq, uptime_ms, seq, system stats (NO ts field). Check SPIFFS threshold during write—if > 80%, prune oldest entries. Increment seq after each write."
  },
  "verification": null,
  "blockers": [],
  "related_tasks": ["task-011", "task-012"],
  "tags": [
    "logging",
    "spiffs",
    "persistence",
    "json",
    "phase-1"
  ]
}
